# 스프링 클라우드를 활용한 MSA 기초

#### 학습 자료

[Spring Cloud를 활용한 MSA 기초](https://www.youtube.com/watch?v=D6drzNZWs-Y&list=PL9mhQYIlKEhdtYdxxZ6hZeb0va2Gm17A5)

### 목표

* 모놀리식이 나온 배경과 아키텍쳐를 이해한다
* Cloud Native한 MSA를 이해한다
* Netflix OSS, Spring Cloud를 통해 MSA를 구축한다.

### 기존 모놀리식 방식의 개발

신규 프로젝트가 시작되면 개발자가 개발한 코드는 하나의 톰캣에서 실행되고 프로그램의 상태는 하나의 DB에 저장된다. 그리고 개발자들은 협업을 위하여 형상관리 툴(svn, git 등)을 사용한다. 하지만 현재는 상용 배포시 톰캣 하나, 데이터베이스 하나를 이용하기 때문에 무중단 배포가 불가능하다.  

그래서 이제는 톰캣 두 개를 두고 앞에 로드밸런서(L4 switch, L7)를 두어 구성한다(High Avaliability). 하나의 톰캣을 배포한 뒤 완료되면 나머지 톰캣을 배포한다(무중단 배포). 그런데 서비스가 잘되서 동시 접속자 수가 1000명 이상이 되었다고 하자. 그러면 두 개의 톰캣으로는 감당이 되지 않아 여러 개의 톰캣을 추가해야 할 것이다(LB 설정 변경). 그리고 배포방식도 변경될 것이다(Jenkins, Ansible, Chef 등). 또한 조직 개편을 하여 상품 팀과 주문팀으로 분리가 되면 다음과 같은 문제 발생할 수 있다.

1. branch merge 시 충돌 발생
2. QA를 어디까지 해야하나? - 정기배포일
3. 팀마다 각자 다른 일정, 배포 이슈
4. etc..

위와 같은 문제를 해결하기 위하여 도메인을 2개로 분리하여 주문팀과 상품팀의 서버를 나눈다. 서로 공통되는 로직은 share.jar로 따로 빼낸다. 하지만 실제로 대부분의 작업은 share.jar에서 이루어지기 때문에 문제는 해결되지 않는다.


회사가 점점 커져감에 따라 개발자도 늘어나고 조직도 커져가는데, 사용되는 데이터베이스는 하나이고 공통 코드(share.jar)는 한 군데 모여있다. 또한 복사 붙여넣기로 오는 중복과 복잡도가 증가한다.

>  콘웨이의 법칙
> * 광범위하게 정의하면 모든 조직은 조직의 의사소통 구조와 똑같은 구조를 갖는 시스템을 설계한다.
> * 콘웨이 법칙은 조직도에 초점을 두지 않고, 실질적인 소통 관계에 관심을 둔다. 너무 많은 통신 관계를 갖는 것은 프로젝트에 대한 진정한 위험이 된다.

### 모놀리식 아키텍쳐의 장단점

* 장점
  * 개발, 배포가 단순하다.
  * Scale-out이 단순하다(서버를 복사하면 됨)
    * 하지만 DB 성능으로 인한 한계가 있다.
* 단점
  * 무겁다
  * 어플리케이션 시작이 오래 걸린다.
  * 기술 스택을 바꾸기 어렵다.
  * 높은 결합도
  * 코드베이스의 책임 한계와 소유권이 불투명
    *  프로젝트 전체를 파악하는 사람이 없고 그에 따라 프로젝트의 경계가 불분명해진다.


### 앞으로의 방향을 결정해야 한다.

1. 새로운 언어, 깔끔한 코드로 전면개편
2. MSA 플랫폼을 구축하여 기존 레거시를 고시시킴


## MSA

MSA란 시스템을 여러개의 독립된 서비스로 나눈 후, 이 서비스를 조합함으로서 기능을 제공하는 아키텍쳐 디자인 패턴이다. 현재까지 공식적인 정의는 없지만 다음과 같은 공감대가 존재한다.

* 각 서비스 간 네트워크를 통해(보통 http) 통신
* 각 서비스는 독립된 배포 단위를 가진다.
* 각 서비스는 쉽게 교체 가능하다.
* 각 서비스는 기능 중심으로 구성된다.
  * ex) 프론트 엔드, 추천, 정산, 상품 등
* 각 서비스에 적합한 프로그래밍 언어, 데이터베이스, 환경으로 만들어진다.
* 서비스의 크기가 작고, 상황에 따라 경계를 정하고, 자율적으로 개발되고, 독립적으로 배포되고, 분산되고, 자동화된 프로세스로 구축되고 배포된다.
* 마이크로서비스는 한 팀에 의해 개발할 수 있는 크기가 상한선이다. 3~9명의 사람들이 개발을 할 수 없을 정도로 커지면 안 된다.

#### 모놀리식 vs 마이크로서비스

![monolithic vs microservice](https://blogs.bmc.com/wp-content/uploads/2018/10/microservices-vs-monolithic-1024x544.png)


#### 기존 모놀리식 방식의 문제를 MSA로 변경

공통 로직(share.jar)를 제거하고 각각의 마이크로서비스 별로 를 가지고 api를 통해서만 서로를 호출한다.

## Cloud Native

클라우드 네이티브의 핵심은 애플리케이션을 어떻게 만들고 배포하는지에 있으며 위치는 중요하지 않다.

> 클라우드 서비스를 활용한다는 것은 컨테이너와 같이 민첩하고 확장 가능한 구성 요소를 사용해서 재사용 가능한 개별적인 기능을 제공하는 것을 의미한다. 이러한 기능은 멀티 클라우드와 같은 여러 기술 경계 간에 매끄럽게 통합되므로 제공 팀이 반복 가능한 자동화와 오케스트레이션을 사용해서 빠르게 작업과정을 반복할 수 있다. - 앤디 맨

### 클라우드 네이티브의 다섯가지 요소
* 신축성(Resiliency): 서비스가 중단이 되어도 (인스턴스가 종료되어도) 전체적인 장애로 퍼지지 않고 빠르게 복구
* 민첩성(Agility): 빠르게 배포하고, 독립적으로 빠르게 운영
* 확장 가능성(Scalable): 수평적으로 확장 가능하게
* 자동화(Automation): 이러한 과정들을 자동화하여 운영에 드는 수고를 줄임
* 무상태(State-less): 각 서비스의 상태는 무상태


## DevOps

#### 전통적 모델
* 개발과 운영 조직의 분리
* 다른 쪽으로 일을 알아서 처리하라고 맡김
#### DevOps
* You run it, you build it. 만들면 운영까지 - 베르너 보겔스, 아마존 CTO
* 개별 팀은 프로젝트 그룹이 아닌, 제품 그룹에 소속
* 운영과 제품 관리 모두가 포함되는 조직적 구조. 제품 팀은 소프트웨어를 만들고 운영하는 데 필요한 모든 것을 보유

## [Twelve-Factors](https://12factor.net/ko/)

* Heroku 클라우드 플랫폼 창시자들이 정립한 애플리케이션 개발 원칙 중 유익한 것을 모아 정리한 것
* 탄력적(elastic)이고 이식성(portability) 있는 배포를 위한 Best Practice

#### 핵심 사상
* 선언적(<->명령적) 형식으로 설정을 자동화해서 프로젝트에 새로 참여하는 동료가 적응하는 데 필요한 시간과 비용을 최소화한다.
* 운영체제에 구애받지 않는 투명한 계약을 통해 다양한 실행 환경에서 작동할 수 있도록 이식성을 극대화한다.
* 현대적인 클라우드 플랫폼 기반 개발을 통해서 서버와 시스템 관리에 대한 부담을 줄인다.
* 개발과 운영의 간극을 최소화해서 지속적인 배포(Continuous Deployment)를 가능하게 하고 애자일성을 최대화한다.
* 도구, 아키텍쳐, 개발 관행을 크게 바꾸지 않아도 서비스 규모의 수직적 확장이 가능하다.

### 12가지 제약 조건

#### 1. 코드베이스
  * 버전 관리되는 하나의 코드베이스가 여러 번 배포된다.
  * 코드베이스와 앱 사이에는 항상 1대1 관계가 성립된다.
    * 하나의 프로젝트에서 여러 서비스를 배포하지 않는다.

#### 2. 종속성
* 애플리케이션의 의존관계는 명시적으로 선언되어야 한다.
* 모든 의존 라이브러리는 아파치 메이븐, 그레들 등의 의존관계 관리 도구를 써서 라이브러리 저장소에서 내려받을 수 있어야 한다.

#### 3. 설정
* 설정 정보는 코드에 있으면 안 되고 실행 환경(환경 변수)에 저장해야 한다.
  * 설정 정보는 애플리케이션 코드와 엄격하기 분리
  * ex) 데이터베이스 정보, cdn, 외부 서비스 인증, 호스트 이름 등

#### 4. 백엔드(지원) 서비스
* 지원 서비스(Backing Service)는 필요에 따라 추가되는 자원으로 취급한다.
  * 지원 서버비스는 애플리케이션의 자원으로 간주한다.
  * ex) 데이터베이스, API 기반 RESTFul 웹 서비스, SMTP 서버, FTP 서버 등
  * ex) 테스트 환경에서 사용하던 임베디드 SQL을 스테이징 환경에서 MySQL로 교체할 수 있어야 한다.

#### 5. 빌드, 릴리즈, 실행
* 철저하게 분리된 빌드와 실행 단계
* 코드베이스는 3단계를 거쳐 (개발용이 아닌) 배포로 변환된다.
  * 빌드 단계: 소스 코드를 가져와 컴파일 후 하나의 패키지를 만든다.
  * 릴리즈 단계: 빌드에 환경설정 정보를 조합한다. 릴리즈 버전은 실행 환경에서 운영될 수 있는 준비가 완료되어 있다.
    * ex) jenkins에서 아티팩트를 만드는 단계
  * 실행 단계: 보통 런타임이라 불리며, 릴리즈 버전 중 하나를 선택해 실행 환경 위에서 애플리케이션을 실행한다.

#### 6. 프로세스
* 애플리케이션을 하나 혹은 여러개의 무상태(stateless) 프로세스로 실행한다.

#### 7. 포트 바인딩
  * 서비스는 포트에 연결해서 외부에 공개한다.
  * 실행 환경에 웹 서버를 따로 추가해줄 필요 없이 스스로 웹 서버를 포함하고 있어서 완전히 자기 완비적(self-contained)이다.

#### 8. 동시성(Concurrency)
* 프로세스 모델을 통해 수평적으로 확장한다.
* 애플리케이션은 필요할 때 마다 프로세스나 스레드를 수평적으로 확장해서 병렬로 실행할 수 있어야 한다.
* 장시간 소요되는 데이터 프로세싱 작업은 스레드풀에 할당해서 스레드 실행기를 통해 수행되어야 한다
* 예를 들어, HTTP 요청은 서블릿 스레드가 처리하고, 시간이 오래 걸리는 작업은 워커 스레드가 처리해야 한다.

#### 9. 처분성(Disposability)
* 빠른 시작과 그레이스풀 셧다운(Graceful Shutdown)을 통한 안정성 극대화
* 애플리케이션은 프로세스 실행 중에 언제든지 중지될 수 있고, 중지될 때 처리되어야 하는 작업을 모두 수행한 다음에 종료될 수 있다.
* 가능한 짧은 시간 내에 시작되어야 한다.

#### 10. 개발과 운영의 일치
* development, staging, production 환경을 최대한 비슷하게 유지
* 개발 환경과 운영 환경을 가능한 동일하게 유지하는 짝맞춤(parity)를 통해 분기(divergence)를 예방할 수 있어야 한다.
* 유념해야 할 세 가지 차이
  * 시간 차이: 개발자는 변경 사항을 운영 환경에 빨리 배포해야 한다.
  * 개인 차이: 코드 변경을 맡은 개발자는 운영 환경으로의 배포 작업까지 할 수 있어야 하고, 모니터링도 할 수 있어야 한다.
  * 도구 차이: 각 실행 환경에서 사용된 기술이나 프레임워크는 동일하게 구성되어야 한다.

#### 11. 로그
* 로그는 이벤트 스트림으로 취급한다
* 로그는 stdout에 남긴다.
* 애플리케이션은 로그 파일 저장에 관여하지 않아야 한다.
* 로그 집계와 저장은 애플리케이션이 아니라 실행 환경에 의해 처리되어야 한다.

#### 12. Admin 프로세스
* admin/maintenance 작업을 일회성 프로세스로 실행
* 실행되는 프로세스와 동일한 환경에서 실행
* admin 코드는 애플리케이션 코드와 함께 배포되어야 한다.

## HTTP, REST API
보통 MSA 구축할 때 REST를 많이 사용한다.

* HTTP
  * 클라이언트의 상태를 갖지 않음(stateless)
  * 각 요청은 자기 완비적(self-contained)
* REST API
  * 원격 자원과 엔티티를 다루는데 초점
  * 동사 대신 명사를, 행위 대신 엔티티에 집중
  * REST는 기술 표준이 아닌 아키텍쳐 제약사항
  * 상태가 없고 요청이 자기 완비적이기 때문에 서비스도 수평적으로 쉽게 확장할 수 있다.